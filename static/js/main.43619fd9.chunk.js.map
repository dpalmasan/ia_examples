{"version":3,"sources":["PuzzleProblem.ts","Utils.ts","SearchProblem.ts","index.js"],"names":["Direction","BinaryHeap","scoreFunction","content","this","element","push","bubbleUp","length","result","end","pop","sinkDown","node","i","n","score","parentN","Math","floor","parent","elemScore","child2N","child1N","swap","child1","child1Score","child2","State","prev","action","SearchProblem","StateSet","set","Set","value","add","hash","has","aStar","problem","heuristic","frontier","state","getCostOfAction","getStartState","explored","size","isGoalState","curr","path","unshift","getSuccessors","forEach","neighbor","EightPuzzle","board","j","Error","direction","zeroPos","getZeroPos","zeroRow","zeroCol","tmp","UP","DOWN","LEFT","RIGHT","console","log","moves","copyBoard","row","iter","validMoves","getPossibleMoves","randomMove","random","move","flat","join","otherPuzzle","EightPuzzleState","puzzle","otherState","equals","EightPuzzleProblem","solvedPuzzle","initialPuzzle","successors","clone","solution","Square","className","props","React","Component","Board","items","col","renderSquare","renderRow","renderPuzzle","Game","actions","setTimeout","forceUpdate","animate","manhattanDistance","goalPos","0","1","2","3","4","5","6","7","8","rowGoal","colGoal","abs","classicManhattanDistance","alert","type","onClick","solvePuzzle","randomize","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.43619fd9.chunk.js","sourcesContent":["import {\n    SearchProblem,\n    State,\n    aStar\n} from \"./SearchProblem\"\n\n\nenum Direction {\n    UP = \"up\",\n    DOWN = \"down\",\n    LEFT = \"left\",\n    RIGHT = \"right\"\n}\n\nclass EightPuzzle {\n    board\n    size: number\n    constructor(board: number[][]) {\n        this.board = board;\n        this.size = 3\n    }\n\n    private getZeroPos() {\n        for (let i = 0; i < this.size; i++) {\n            for (let j = 0; j < this.size; j++) {\n                if (this.board[i][j] === 0) {\n                    return [i, j];\n                }\n            }\n        }\n        throw new Error(\"Invalid board!\");\n    }\n\n    move (direction: string) {\n        let zeroPos = this.getZeroPos();\n        let zeroRow = zeroPos[0];\n        let zeroCol = zeroPos[1];\n        let tmp: number = this.board[zeroRow][zeroCol];\n        switch (direction) {\n            case Direction.UP: {\n                this.board[zeroRow][zeroCol] = this.board[zeroRow - 1][zeroCol];\n                this.board[zeroRow - 1][zeroCol] = tmp;\n                break;\n            }\n            case Direction.DOWN: {\n                this.board[zeroRow][zeroCol] = this.board[zeroRow + 1][zeroCol];\n                this.board[zeroRow + 1][zeroCol] = tmp;\n                break;\n            }\n            case Direction.LEFT: {\n                this.board[zeroRow][zeroCol] = this.board[zeroRow][zeroCol - 1];\n                this.board[zeroRow][zeroCol - 1] = tmp;\n                break;\n            }\n            case Direction.RIGHT: {\n                this.board[zeroRow][zeroCol] = this.board[zeroRow][zeroCol + 1];\n                this.board[zeroRow][zeroCol + 1] = tmp;\n                break;\n            }\n            default: {\n                console.log(direction);\n                throw new Error(\"Invalid direction!\");\n            }\n        }\n    }\n\n    getPossibleMoves() {\n        let moves = [];\n        let zeroPos = this.getZeroPos();\n        let zeroRow = zeroPos[0];\n        let zeroCol = zeroPos[1];\n\n        if (zeroRow > 0) {\n            moves.push(Direction.UP);\n        }\n        if (zeroRow < this.size - 1) {\n            moves.push(Direction.DOWN);\n        }\n        if (zeroCol > 0) {\n            moves.push(Direction.LEFT);\n        }\n        if (zeroCol < this.size - 1) {\n            moves.push(Direction.RIGHT);\n        }\n        return moves;\n    }\n\n    clone() {\n        let copyBoard = [];\n        for (let i = 0; i < this.size; i++) {\n            let row = [];\n            for (let j = 0; j < this.size; j++) {\n                row.push(this.board[i][j]);\n            }\n            copyBoard.push(row);\n        }\n        return new EightPuzzle(copyBoard);\n    }\n\n    randomize(iter: number = 100) {\n        for (let i = 0; i < iter; i++) {\n            let validMoves = this.getPossibleMoves();\n            let randomMove = validMoves[Math.floor(Math.random()*validMoves.length)];\n            this.move(randomMove);\n        }\n    }\n\n    hash(): string {\n        return this.board.flat().join(\"\");\n\n    }\n\n    equals(otherPuzzle: EightPuzzle) {\n        return this.hash() === otherPuzzle.hash();\n    }\n}\n\nclass EightPuzzleState extends State {\n    puzzle: EightPuzzle\n    moves: number\n    constructor(puzzle: EightPuzzle, moves: number, prev: State = null, action: string = null) {\n        super(prev, action);\n        this.puzzle = puzzle;\n        this.moves = moves;\n    }\n\n    equals(otherState: EightPuzzleState) {\n        return this.puzzle.equals(otherState.puzzle);\n    }\n\n    hash() {\n        return this.puzzle.hash();\n    }\n}\n\nclass EightPuzzleProblem extends SearchProblem {\n    initialPuzzle: EightPuzzle\n    solvedPuzzle: EightPuzzle\n    constructor (puzzle: EightPuzzle, solvedPuzzle: EightPuzzle) {\n        super();\n        this.initialPuzzle = puzzle;\n        this.solvedPuzzle = solvedPuzzle;\n    }\n\n    getCostOfAction(state: EightPuzzleState): number {\n        return state.moves;\n    }\n\n    getStartState(): EightPuzzleState {\n        return new EightPuzzleState(this.initialPuzzle, 0);\n    }\n\n    getSuccessors(state: EightPuzzleState) {\n        let successors = [];\n        let validMoves = state.puzzle.getPossibleMoves();\n        for (const direction of validMoves) {\n            let puzzle: EightPuzzle = state.puzzle.clone();\n            puzzle.move(direction);\n            successors.push(new EightPuzzleState(puzzle, state.moves + 1, state, direction));\n        }\n        return successors;\n    }\n\n    isGoalState(state: EightPuzzleState) {\n        return state.puzzle.equals(this.solvedPuzzle);\n    }\n\n}\n\n/**\n * Computes Manhattan distance heuristic. This will only work\n * for the classic puzzle goal configuration and only for a 3x3\n * board. This can be generalized, but I left that as an exercise.\n * @param state state to be evaluated.\n */\nfunction classicManhattanDistance(state: EightPuzzleState) {\n    if (state.puzzle.board.length !== 3) {\n        throw new Error(\"This heuristic is only for 3x3 puzzle, donÂ´t be lazy!\");\n    }\n    let board = state.puzzle.board;\n    let manhattanDistance = 0;\n\n    let goalPos = {\n        0: [0, 0], 1: [0, 1], 2: [0, 2],\n        3: [1, 0], 4: [1, 1], 5: [1, 2],\n        6: [2, 0], 7: [2, 1], 8: [2, 2]\n    }\n\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            let rowGoal = goalPos[board[i][j]][0];\n            let colGoal = goalPos[board[i][j]][1];\n            manhattanDistance += Math.abs(i - rowGoal) + Math.abs(j - colGoal);\n        }\n    }\n    return manhattanDistance;\n}\n\n\nlet puzzle = new EightPuzzle([\n    [8, 7, 6],\n    [5, 4, 3],\n    [2, 1, 0]\n]);\nlet problem = new EightPuzzleProblem(puzzle,\n    new EightPuzzle(\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8]]));\n\n\n// Null heuristic just for testing\nlet solution = aStar(problem, (state) => 0);\n\nconsole.log(puzzle);\nsolution.forEach((action) => {\n    puzzle.move(action);\n})\nconsole.log(puzzle);\n\nexport {\n    EightPuzzle,\n    EightPuzzleProblem,\n    classicManhattanDistance\n}","// https://www.davideaversa.it/blog/typescript-binary-heap/\nexport class BinaryHeap<T> {\n    content: T[];\n    scoreFunction: (x: T) => number;\n\n    constructor(scoreFunction: (x: T) => number) {\n        this.content = [];\n        this.scoreFunction = scoreFunction;\n    }\n\n    push(element: T) {\n        this.content.push(element);\n        this.bubbleUp(this.content.length - 1);\n    }\n\n    pop(): T {\n        let result = this.content[0];\n        let end = this.content.pop();\n        if (this.content.length > 0) {\n            this.content[0] = end;\n            this.sinkDown(0);\n        }\n        return result;\n    }\n\n    remove(node: T) {\n        let length = this.content.length;\n        // To remove a value, we must search through the array to find\n        // it.\n        for (var i = 0; i < length; i++) {\n            if (this.content[i] !== node) continue;\n            // When it is found, the process seen in 'pop' is repeated\n            // to fill up the hole.\n            let end = this.content.pop();\n            // If the element we popped was the one we needed to remove,\n            // we're done.\n            if (i === length - 1) break;\n            // Otherwise, we replace the removed element with the popped\n            // one, and allow it to float up or sink down as appropriate.\n            this.content[i] = end;\n            this.bubbleUp(i);\n            this.sinkDown(i);\n            break;\n        }\n    }\n\n    size() {\n        return this.content.length;\n    }\n\n    private bubbleUp(n: number) {\n        // Fetch the element that has to be moved.\n        let element = this.content[n], score = this.scoreFunction(element);\n        // When at 0, an element can not go up any further.\n        while (n > 0) {\n            // Compute the parent element's index, and fetch it.\n            let parentN = Math.floor((n + 1) / 2) - 1,\n                parent = this.content[parentN];\n            // If the parent has a lesser score, things are in order and we\n            // are done.\n            if (score >= this.scoreFunction(parent))\n                break;\n\n            // Otherwise, swap the parent with the current element and\n            // continue.\n            this.content[parentN] = element;\n            this.content[n] = parent;\n            n = parentN;\n        }\n    }\n\n    private sinkDown(n: number) {\n        // Look up the target element and its score.\n        var length = this.content.length,\n            element = this.content[n],\n            elemScore = this.scoreFunction(element);\n\n        while (true) {\n            // Compute the indices of the child elements.\n            var child2N = (n + 1) * 2, child1N = child2N - 1;\n            // This is used to store the new position of the element,\n            // if any.\n            var swap = null;\n            // If the first child exists (is inside the array)...\n            if (child1N < length) {\n                // Look it up and compute its score.\n                var child1 = this.content[child1N],\n                    child1Score = this.scoreFunction(child1);\n                // If the score is less than our element's, we need to swap.\n                if (child1Score < elemScore)\n                    swap = child1N;\n            }\n            // Do the same checks for the other child.\n            if (child2N < length) {\n                var child2 = this.content[child2N],\n                    child2Score = this.scoreFunction(child2);\n                if (child2Score < (swap == null ? elemScore : child1Score))\n                    swap = child2N;\n            }\n\n            // No need to swap further, we are done.\n            if (swap == null) break;\n\n            // Otherwise, swap and continue.\n            this.content[n] = this.content[swap];\n            this.content[swap] = element;\n            n = swap;\n        }\n    }\n} ","/**\n * Probably I should create an interface or something to have\n * state logic encapsulated inside the SearchProblem.\n */\nimport { BinaryHeap } from \"./Utils\"\n\n// Abstract class for defining states for a particular problem\nexport abstract class State {\n    prev: State\n    action: string;\n    constructor (prev: State, action: string) { \n        this.prev = prev;\n        this.action = action;\n    }\n\n    abstract equals(otherState: State): boolean;\n    abstract hash(): string;\n}\n\n// Abstract class for a search problem\nexport abstract class SearchProblem {\n    abstract getStartState() : State;\n    abstract isGoalState(state: State) : boolean;\n    abstract getSuccessors(state: State) : State[];\n    abstract getCostOfAction(state: State) : number;\n}\n\nexport class RouteProblemState extends State {\n    position: [number, number]\n    cost: number\n    constructor (position: [number, number], cost: number, prev: State = null, action: string = null) {\n        super(prev, action);\n        this.position = position;\n        this.cost = cost;\n    }\n\n    equals(otherState: RouteProblemState): boolean {\n        return this.position[0] === otherState.position[0] \n            && this.position[1] === otherState.position[1];\n    }\n\n    hash(): string {\n        return this.position.toString();\n    }\n}\n\n// Defines a route problem with visited restriction\nexport class RouteProblem extends SearchProblem {\n    initialPosition: [number, number]\n    goalPosition: [number, number]\n    visited: boolean[][]\n\n    constructor (initialPosition: [number, number], goalPosition: [number, number], visited: boolean[][]) {\n        super();\n        this.initialPosition = initialPosition;\n        this.goalPosition = goalPosition;\n        this.visited = visited;\n    }\n\n    private coordIsGoal(x, y) {\n        return x === this.goalPosition[1] && y === this.goalPosition[0];\n    }\n\n    getStartState() {\n        return new RouteProblemState(this.initialPosition, 0);\n    }\n\n    isGoalState(state: RouteProblemState) : boolean{\n        return state.position[0] === this.goalPosition[0]\n            && state.position[1] === this.goalPosition[1];\n    }\n\n    getSuccessors(state: RouteProblemState): State[] {\n        let x: number = state.position[1];\n        let y: number = state.position[0];\n        let m: number = this.visited.length;\n        let n: number = this.visited[0].length;\n        let cost: number = state.cost;\n\n        let successors: RouteProblemState[] = [];\n        if (x > 0 && (this.visited[y][x - 1] || this.coordIsGoal(x - 1, y))) {\n            successors.push(new RouteProblemState([y, x - 1], cost + 1, state, \"left\"));\n        }\n        if (x < n - 1 && (this.visited[y][x + 1] || this.coordIsGoal(x + 1, y))) {\n            successors.push(new RouteProblemState([y, x + 1], cost + 1, state, \"right\"));\n        }\n        if (y > 0 && (this.visited[y - 1][x] || this.coordIsGoal(x, y - 1))) {\n            successors.push(new RouteProblemState([y - 1, x], cost + 1, state, \"up\"));\n        }\n        if (y < m - 1 && (this.visited[y + 1][x] || this.coordIsGoal(x, y + 1))) {\n            successors.push(new RouteProblemState([y + 1, x], cost + 1, state, \"down\"));\n        }\n        return successors;\n    }\n\n    getCostOfAction(state: RouteProblemState): number {\n        return state.cost;\n    }\n}\n\nclass StateSet {\n    set: Set<string>\n    constructor () {\n        this.set = new Set<string>();\n    }\n\n    add(value: State): void {\n        this.set.add(value.hash());\n    }\n\n    has(value: State): boolean {\n        return this.set.has(value.hash());\n    }\n}\n\nexport function aStar(problem: SearchProblem, heuristic: (state: State) => number ) {\n    let frontier = new BinaryHeap<State>(\n        (state: State) => heuristic(state) + problem.getCostOfAction(state));\n\n    frontier.push(problem.getStartState());\n    let explored = new StateSet();\n    \n    while (frontier.size() !== 0) {\n        let state: State = frontier.pop();\n        explored.add(state);\n\n        if (problem.isGoalState(state)) {\n            let curr: State = state;\n            let path = [];\n            while (curr.prev !== null) {\n                path.unshift(curr.action);\n                curr = curr.prev;\n            }\n            return path;\n        }\n\n        let neighbors: State[] = problem.getSuccessors(state);\n        neighbors.forEach( (neighbor) => {\n            if (!explored.has(neighbor)) {\n                frontier.push(neighbor);\n            }\n        });\n    }\n    return [];\n}\n","import { EightPuzzle, EightPuzzleProblem, classicManhattanDistance } from './PuzzleProblem';\nimport { aStar } from './SearchProblem';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'bootstrap/dist/css/bootstrap.css';\n\nclass Square extends React.Component {\n  render() {\n    return (\n      <button className=\"square\">\n        { (this.props.value) ? this.props.value : \"\" }\n      </button>\n    );\n  }\n}\n\nclass Board extends React.Component {\n  renderSquare(i) {\n    return <Square value={i} />;\n  }\n\n  renderRow(row) {\n    const items = [];\n    for (let col = 0; col < this.props.puzzle.size; col++) {\n      items.push(this.renderSquare(this.props.puzzle.board[row][col]));\n    }\n    return <div className=\"board-row\">\n      {items}\n    </div>\n  }\n\n  renderPuzzle() {\n    const items = [];\n    for (let row = 0; row < this.props.puzzle.size; row++) {\n      items.push(this.renderRow(row));\n    }\n    return items;\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"title\">8-Puzzle Demo</div>\n          {this.renderPuzzle()}\n      </div>\n    );\n  }\n}\n\nclass Game extends React.Component {\n  constructor() {\n    super();\n    this.puzzle = new EightPuzzle([\n      [8, 7, 6],\n      [5, 4, 3],\n      [2, 1, 0]\n    ]);\n  }\n\n  animate(actions, i) {\n    setTimeout( () => {\n      if (i < actions.length) {\n        this.puzzle.move(actions[i]);\n        this.forceUpdate();\n        this.animate(actions, i + 1);\n      }\n    }, 500)\n  }\n\n  solvePuzzle() {\n    let problem = new EightPuzzleProblem(this.puzzle,\n      new EightPuzzle(\n          [[0, 1, 2], [3, 4, 5], [6, 7, 8]]));\n  \n    // Null heuristic just for testing\n    let solution = aStar(problem, (state) => classicManhattanDistance(state));\n    this.animate(solution, 0)\n    alert(\"Solved in \" + solution.length + \" steps\")\n  }\n\n  render() {\n    return (\n      <div className=\"game\">\n        <div className=\"game-board\">\n          <Board puzzle={this.puzzle}/>\n        </div>\n        <div className=\"game-info\">\n          <div>\n            <button \n              type=\"button\"\n              className=\"btn btn-success\"\n              onClick={ () => { this.solvePuzzle() }}>\n              Solve!\n            </button>\n          </div>\n          <div>\n            <button \n              type=\"button\"\n              className=\"btn btn-primary\"\n              onClick={() => { this.puzzle.randomize(); this.forceUpdate() }}>\n              Randomize\n            </button>\n            </div>\n        </div>\n      </div>\n    );\n  }\n}\n\n// ========================================\n\nReactDOM.render(\n  <Game />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}